/// An example of a forward pass of a linear layer.
/// Generated by linear.ipynb.
module {
	func.func @forward(%v0: memref<10x10xf32>,
		%v1: memref<1x10xf32>,
		%v2: memref<16x10xf32>) -> (memref<16x10xf32>) {
		%zero = arith.constant 0 : index
		%v3 = memref.alloc() : memref<16x10xf32>
		affine.for %arg0 = 0 to 16 {
			affine.for %arg1 = 0 to 10 {
				%s5 = arith.constant 0.0 : f32
				memref.store %s5, %v3[%arg0, %arg1] : memref<16x10xf32>
				affine.for %arg2 = 0 to 10 {
					%s0 = memref.load %v3[%arg0, %arg1] : memref<16x10xf32>
					%s1 = memref.load %v2[%arg0, %arg2] : memref<16x10xf32>
					%s2 = memref.load %v0[%arg2, %arg1] : memref<10x10xf32>
					%s3 = arith.mulf %s1, %s2 : f32
					%s4 = arith.addf %s0, %s3 : f32
					memref.store %s4, %v3[%arg0, %arg1] : memref<16x10xf32>
				}
			}
		}

		%v4 = memref.alloc() : memref<16x10xf32>
		affine.for %arg0 = 0 to 16 {
			affine.for %arg1 = 0 to 10 {
				%s0 = memref.load %v3[%arg0, %arg1] : memref<16x10xf32>
				%s1 = memref.load %v1[%zero, %arg1] : memref<1x10xf32>
				%s2 = arith.addf %s0, %s1 : f32 
				memref.store %s2, %v4[%arg0, %arg1] : memref<16x10xf32>
			}
		}

		return %v4 : memref<16x10xf32>

	}
}
